<MudTable @ref="Table" Class="ma-4" Dense="true" MultiSelection="true"
          Items="@Restaurants" Hover="true" SelectedItemsChanged="@((HashSet<RestaurantData> changed) => OnSelectedItemChangedAsync(changed))">
  <HeaderContent>
    <MudTh>Name</MudTh>
    <MudTh>PaymentMethod</MudTh>
  </HeaderContent>
  <RowTemplate>
    <MudTd DataLabel="Name">@context.Name</MudTd>
    <MudTd DataLabel="PaymentMethod">@GetPaymentMethodString(context.PaymentMethod, " ")</MudTd>
  </RowTemplate>
</MudTable>

@code {

    public MudTable<RestaurantData> Table { get; set; }

    private List<RestaurantData> Restaurants { get; set; } = new();

    [Inject]
    public StorageService Storage { get; set; }

    [Inject]
    protected UserService UserService { get; set; }

    protected override async Task OnInitializedAsync()
    {
      Restaurants = await Storage.RestaurantsTask;
      var choicesEntity = await Storage.GetSelectionAsync(UserService.UserData.GetUserId());
      if (choicesEntity != null)
      {
        var choices = choicesEntity.GetChoicesTyped();
        // Warning BL0005: As long as Table doesn't have a SetSelectedItems method, we don't have a choice
        Table.SelectedItems = new HashSet<RestaurantData>(Restaurants.Where(x => choices.Contains(x.RowKey)));
      }
    }

    private async Task OnSelectedItemChangedAsync(IEnumerable<RestaurantData> changed)
    {
      await UserService.SetSelectionAsync(changed.Select(x => x.RowKey).ToList());
    }

    private static string GetPaymentMethodString(PaymentMethod method, string separator)
    {
      string MapToEmoji(PaymentMethod m) =>
        m switch
        {
          PaymentMethod.Cash => "ðŸ’µ",
          PaymentMethod.BankCard => "ðŸ’³",
          PaymentMethod.SzepCard => "SZÃ‰P",
          _ => throw new ArgumentOutOfRangeException()
        };

      return string.Join(separator, method.ToValues().Select((Func<PaymentMethod, string>)MapToEmoji));
    }

}
