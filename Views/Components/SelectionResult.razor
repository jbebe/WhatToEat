<MudCard Class="ma-4">
  <MudCardContent>
    <strong>Selection result:</strong>
    <MudList>
      @foreach (var (count, ids) in Results)
      {
        <MudPaper>
          <MudListItem>
            @count vote@(count != 1 ? "s" : ""):
            <p>@(string.Join(", ", ids.Select(x => x.Name)))</p>
          </MudListItem>
        </MudPaper>
      }
    </MudList>
  </MudCardContent>
</MudCard>

@code {

  private List<(int Count, List<RestaurantData> Restaurants)> Results { get; set; } = new();

  [Inject]
  protected StorageService StorageService { get; set; }

  [Inject]
  protected UserService UserService { get; set; }

  protected override async Task OnInitializedAsync()
  {
    UserService.OnBroadcastChoiceChanged -= OnBroadcastChoiceChangedAsync;
    UserService.OnBroadcastChoiceChanged += OnBroadcastChoiceChangedAsync;

    await UpdateChoicesAsync();
  }

  public async Task UpdateChoicesAsync()
  {
    var restaurants = (await StorageService.GetRestaurantsAsync()).ToDictionary(x => x.GetId());
    var allUsersChoices = await UserService.GetAllChoicesAsync(todayOnly: true);
    
    Results = allUsersChoices
      .SelectMany(x => x.GetChoicesTyped()) // get flat array of restaurant ids
      .GroupBy(x => x) // group by ids, making lists of the same ids
      .ToDictionary(x => x.Key, x => x.Count()) // aggregate these same ids by count, create id => count map
      .GroupBy(x => x.Value, x => x.Key) // group by count, collect every id that has the same count
      .ToDictionary(x => x.Key) // join ids by comma, create count => id list
      .OrderByDescending(x => x.Key) // order key-pairs by count descending
      .Take(3) // select the 3 most loved restaurant-list
      .Select(x => (x.Key, x.Value.Select(y => restaurants[y]).ToList()))
      .ToList();
  }

  public async Task OnBroadcastChoiceChangedAsync(BroadcastMessage message)
  {
    await UpdateChoicesAsync();
    await InvokeAsync(StateHasChanged);
  }
}
